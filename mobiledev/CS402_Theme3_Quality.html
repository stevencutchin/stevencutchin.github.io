<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CS 402 — Theme 3: Quality</title>
<style>
  @page { size: letter; margin: 1in; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Segoe UI', Arial, Helvetica, sans-serif;
    font-size: 15px;
    line-height: 1.7;
    color: #2c2c2c;
    max-width: 820px;
    margin: 0 auto;
    padding: 48px 32px;
    background: #fff;
  }
  .doc-header {
    text-align: center;
    margin-bottom: 36px;
    padding-bottom: 24px;
    border-bottom: 2px solid #1B3A5C;
  }
  .doc-header h1 { font-size: 26px; color: #1B3A5C; margin-bottom: 4px; font-weight: 700; }
  .doc-header .semester { font-size: 16px; color: #666; margin-bottom: 8px; }
  .doc-header .subtitle { font-size: 18px; color: #2E5D8A; font-weight: 600; }
  h2 {
    font-size: 20px; color: #1B3A5C; margin: 36px 0 14px;
    padding-bottom: 6px; border-bottom: 1px solid #d0dce6; font-weight: 700;
  }
  h3 { font-size: 17px; color: #2E5D8A; margin: 24px 0 10px; font-weight: 600; }
  p { margin-bottom: 14px; color: #333; }
  .callout {
    margin: 20px 0; padding: 16px 20px; background: #f0f6fb;
    border-left: 4px solid #2E5D8A; border-radius: 0 6px 6px 0; color: #333;
  }
  .callout strong { color: #1B3A5C; }
  .callout-warn {
    margin: 20px 0; padding: 16px 20px; background: #fef9f0;
    border-left: 4px solid #d4880f; border-radius: 0 6px 6px 0; color: #333;
  }
  .callout-warn strong { color: #8a5a0a; }
  ul, ol { margin: 10px 0 16px 24px; color: #333; }
  li { margin-bottom: 6px; }
  table {
    width: 100%; border-collapse: collapse; margin: 16px 0 20px; font-size: 14px;
  }
  th {
    background: #1B3A5C; color: #fff; font-weight: 600; padding: 10px 14px; text-align: left;
  }
  td { padding: 9px 14px; border-bottom: 1px solid #ddd; vertical-align: top; }
  tr:nth-child(even) { background: #f4f8fb; }
  code {
    font-family: 'Consolas', 'Courier New', monospace; background: #f0f0f0;
    padding: 2px 6px; border-radius: 3px; font-size: 14px;
  }
  pre {
    background: #1e1e2e; color: #cdd6f4; padding: 16px 20px; border-radius: 6px;
    overflow-x: auto; margin: 12px 0 18px; font-size: 13.5px; line-height: 1.5;
  }
  pre .kw { color: #cba6f7; }
  pre .fn { color: #89b4fa; }
  pre .str { color: #a6e3a1; }
  pre .cm { color: #6c7086; font-style: italic; }
  pre .tag { color: #f38ba8; }
  pre .attr { color: #fab387; }
  .section-intro { font-size: 16px; color: #444; font-style: italic; margin-bottom: 20px; }
  @media print {
    body { padding: 0; max-width: none; }
    h2 { break-after: avoid; }
    .callout, .callout-warn, pre { break-inside: avoid; }
  }
</style>
</head>
<body>

<div class="doc-header">
  <h1>CS 402 — Mobile Application Development</h1>
  <div class="semester">Spring 2026</div>
  <div class="subtitle">Theme 3: Quality — Design, Testing, and User Experience</div>
</div>

<p class="section-intro">
  You can write code that compiles, runs, and produces the right output — and it can still be a bad app. This theme is about the gap between "it works" and "it's good." Quality has two faces: what the user experiences (design) and what the engineer verifies (testing).
</p>


<h2>1. UI Design Principles for Mobile</h2>

<p>
  Mobile UI design operates under constraints that don't exist on the web or desktop. You have a small screen, imprecise input (fingertips instead of a mouse cursor), a distracted user (standing in line, walking, glancing between conversations), and no guarantee of how long they'll spend in your app. Good mobile design respects all of these realities.
</p>

<h3>1.1 Touch Targets and Fitts's Law</h3>

<p>
  Fitts's Law, a foundational principle from human-computer interaction, says that the time to reach a target is a function of the target's size and distance. On mobile, this has a very practical implication: <strong>tap targets must be large enough for a fingertip.</strong>
</p>

<p>
  Both Apple and Google specify minimum touch target sizes. Apple's Human Interface Guidelines recommend at least 44×44 points. Google's Material Design specifies at least 48×48 density-independent pixels. These aren't suggestions — violating them leads to frustrated users who tap the wrong thing or can't hit the button at all.
</p>

<div class="callout">
  <strong>The Thumb Zone:</strong> Most people hold their phone with one hand and navigate with their thumb. Research by Steven Hoober shows that the easiest area to reach is an arc across the center and bottom of the screen. The top corners are the hardest. This is why mobile navigation has moved to the bottom of the screen (tab bars) and why destructive actions should never be placed where they're easy to hit accidentally.
</div>

<h3>1.2 Visual Hierarchy</h3>

<p>
  On a small screen, you can't show everything at once. Visual hierarchy is how you tell the user what matters most. The tools available are:
</p>

<ul>
  <li><strong>Size</strong> — Larger elements draw attention first. Headlines should be visibly larger than body text.</li>
  <li><strong>Weight</strong> — Bold text stands out from regular text. Use sparingly — if everything is bold, nothing is.</li>
  <li><strong>Color and contrast</strong> — High-contrast elements (dark text on light background, or a bright accent color on a neutral background) command attention. Low-contrast elements recede.</li>
  <li><strong>Spacing</strong> — White space (or "negative space") groups related elements and separates unrelated ones. Crowded interfaces feel overwhelming; well-spaced ones feel calm and organized.</li>
  <li><strong>Position</strong> — Content at the top of the screen and left side (in LTR languages) is seen first.</li>
</ul>

<p>
  A common mistake is treating every element as equally important. If your screen has three equally-sized buttons, a wall of same-sized text, and no clear focal point, the user doesn't know where to look. Decide what the <em>one thing</em> the user should do on each screen is, and make that action visually dominant.
</p>

<h3>1.3 Consistency and Platform Conventions</h3>

<p>
  Users arrive at your app with expectations shaped by every other app on their phone. iOS users expect back navigation via a swipe from the left edge. Android users expect a hardware or virtual back button. Both platforms have conventions for tab bars, navigation patterns, pull-to-refresh, and alert dialogs.
</p>

<p>
  Violating platform conventions isn't creative — it's confusing. Your app doesn't exist in isolation; it exists inside an ecosystem where muscle memory matters. A settings icon should look like a gear. A delete action should be red. Swipe-to-dismiss should go in the expected direction. These are not arbitrary rules — they reduce cognitive load by leveraging what the user already knows.
</p>

<div class="callout-warn">
  <strong>The Custom UI Trap:</strong> It's tempting to design a completely custom visual language for your app — unique navigation patterns, novel gesture interactions, unconventional iconography. Resist this urge unless you have an extremely compelling reason. Every novel interaction you introduce is something the user has to learn, and most users won't invest the effort. Use platform conventions as your baseline and customize within that framework.
</div>

<h3>1.4 Feedback and Responsiveness</h3>

<p>
  Every user action should produce visible feedback. When a user taps a button, the button should visually respond — immediately, within 100 milliseconds. If an operation takes time (loading data, saving to disk), show a loading indicator. If an operation succeeds, confirm it. If it fails, explain what happened and what the user can do.
</p>

<p>
  The perception of speed matters as much as actual speed. A screen that shows a skeleton layout (placeholder shapes where content will appear) while loading feels faster than one that shows a blank screen, even if both take the same amount of time. Progress indicators make waits feel shorter than spinners. These aren't tricks — they're honest communication about what the app is doing.
</p>

<h3>1.5 Accessibility</h3>

<p>
  Accessible design isn't a feature — it's a quality standard. Mobile platforms provide robust accessibility frameworks (VoiceOver on iOS, TalkBack on Android) that read screen content aloud for users with visual impairments. For your app to work with these tools, you need to:
</p>

<ul>
  <li>Label all interactive elements with descriptive text (React Native's <code>accessibilityLabel</code> prop).</li>
  <li>Maintain sufficient color contrast (WCAG guidelines specify a 4.5:1 ratio for normal text).</li>
  <li>Never convey information through color alone — always pair color with text or icons.</li>
  <li>Support Dynamic Type / system font scaling, so users who need larger text can use your app.</li>
  <li>Ensure all functionality is reachable via screen reader navigation, not just visual interaction.</li>
</ul>

<p>
  Building accessibly from the start is vastly easier than retrofitting it later, and it often improves the experience for all users — clearer labels, better contrast, and logical navigation benefit everyone.
</p>


<h2>2. Information Architecture</h2>

<p>
  Before a single pixel is placed, you need to decide how information is organized in your app. Information architecture (IA) is the structural design of how content is categorized, labeled, and connected.
</p>

<h3>2.1 Navigation Patterns</h3>

<p>
  Mobile apps typically use one of a few navigation patterns, often in combination:
</p>

<table>
  <tr>
    <th>Pattern</th>
    <th>When to Use</th>
    <th>Example</th>
  </tr>
  <tr>
    <td><strong>Tab Bar</strong></td>
    <td>3–5 top-level sections of equal importance</td>
    <td>Instagram (Home, Search, Reels, Shop, Profile)</td>
  </tr>
  <tr>
    <td><strong>Stack Navigation</strong></td>
    <td>Drilling into detail from a list (master/detail pattern)</td>
    <td>Settings → WiFi → Network Details</td>
  </tr>
  <tr>
    <td><strong>Drawer</strong></td>
    <td>Many sections where a tab bar would be too crowded</td>
    <td>Gmail (Inbox, Sent, Drafts, Labels...)</td>
  </tr>
  <tr>
    <td><strong>Modal</strong></td>
    <td>Focused tasks that interrupt the main flow</td>
    <td>Composing a new email, confirming a destructive action</td>
  </tr>
</table>

<p>
  The rule of thumb: users should always know where they are, how they got there, and how to get back. If a user feels lost in your app, the navigation structure has failed.
</p>


<h2>3. Testing Mobile Applications</h2>

<p>
  Design quality is what the user sees. Testing quality is what the engineer verifies. In mobile development, testing is both more important and more difficult than on the web or desktop, because you're dealing with device fragmentation, platform differences, network variability, and lifecycle events that can interrupt your app at any moment.
</p>

<h3>3.1 The Testing Pyramid</h3>

<p>
  The testing pyramid is a model for how to distribute your testing effort across three levels:
</p>

<ul>
  <li><strong>Unit Tests (base of the pyramid, most tests)</strong> — Test individual functions and components in isolation. Does this helper function format dates correctly? Does this component render the right text given certain props? Unit tests are fast, cheap, and should cover the majority of your logic.</li>
  <li><strong>Integration Tests (middle)</strong> — Test how components work together. When the user types in the search box and presses submit, does the list filter correctly? Integration tests verify that the pieces fit.</li>
  <li><strong>End-to-End Tests (top, fewest tests)</strong> — Test the full application running on a real device or emulator, simulating real user interactions. These are slow and expensive but catch issues that no other test level can: layout breaks on specific screen sizes, performance problems, platform-specific bugs.</li>
</ul>

<h3>3.2 Testing in React Native</h3>

<p>
  The React Native ecosystem provides tools at each level of the pyramid:
</p>

<p>
  <strong>Jest</strong> is the standard test runner for JavaScript and React projects. It runs unit and integration tests in a Node.js environment — no device or emulator needed, which makes it fast. Jest includes a powerful assertion library, mocking capabilities, and snapshot testing.
</p>

<p>
  <strong>React Native Testing Library</strong> (RNTL) sits on top of Jest and provides utilities for rendering components and querying the resulting tree — much like a user would interact with it. Instead of testing implementation details (which internal state changed?), RNTL encourages testing behavior (does the screen show the right content after the user taps this button?).
</p>

<pre><span class="kw">import</span> { render, fireEvent } <span class="kw">from</span> <span class="str">'@testing-library/react-native'</span>;
<span class="kw">import</span> Counter <span class="kw">from</span> <span class="str">'./Counter'</span>;

<span class="fn">test</span>(<span class="str">'increments count when button pressed'</span>, () => {
  <span class="kw">const</span> { getByText } = <span class="fn">render</span>(<span class="tag">&lt;Counter /&gt;</span>);
  
  <span class="fn">expect</span>(<span class="fn">getByText</span>(<span class="str">'Count: 0'</span>)).<span class="fn">toBeTruthy</span>();
  
  <span class="fn">fireEvent</span>.<span class="fn">press</span>(<span class="fn">getByText</span>(<span class="str">'Increment'</span>));
  
  <span class="fn">expect</span>(<span class="fn">getByText</span>(<span class="str">'Count: 1'</span>)).<span class="fn">toBeTruthy</span>();
});</pre>

<p>
  This test renders the Counter component, verifies the initial display, simulates a button press, and verifies the updated display. Notice that it doesn't reference <code>useState</code> or <code>setCount</code> — it only tests what the user would see and do. This is deliberate: tests tied to implementation details break when you refactor, even if the behavior is unchanged.
</p>

<h3>3.3 Snapshot Testing</h3>

<p>
  Snapshot tests capture the rendered output of a component and save it to a file. On subsequent runs, Jest compares the current output to the saved snapshot and fails if anything changed. This is useful for catching unintended visual changes — a typo in a label, a missing style, a component that accidentally disappeared.
</p>

<p>
  The tradeoff is that snapshot tests are brittle: they fail on <em>any</em> change, intentional or not. When you intentionally update a component's output, you have to update the snapshot. Use snapshot testing as a safety net for stable components, not as your primary testing strategy.
</p>

<h3>3.4 Mobile-Specific Testing Challenges</h3>

<p>
  Mobile testing introduces challenges you won't encounter in web or desktop testing:
</p>

<ul>
  <li><strong>Device fragmentation</strong> — Android runs on thousands of different devices with different screen sizes, resolutions, OS versions, and manufacturer customizations. You can't test on all of them, but you should test on a representative range.</li>
  <li><strong>Network conditions</strong> — Your app needs to work on fast WiFi, slow 3G, and no connection at all. Test with network throttling and airplane mode.</li>
  <li><strong>Lifecycle interruptions</strong> — Incoming calls, notifications, low battery warnings, and the user switching to another app all interrupt your app. Test that state is preserved across these interruptions.</li>
  <li><strong>Performance on real devices</strong> — Emulators run on your development machine's hardware, which is typically much more powerful than the target device. Performance issues only show up on real hardware.</li>
</ul>

<div class="callout">
  <strong>The Cost of Not Testing:</strong> Mobile app releases are expensive. On iOS, App Store review takes 1–3 days. On Android, staged rollouts take time. A bug that ships to production can't be fixed instantly — users are stuck with the broken version until the update propagates. This is why testing is not optional in mobile development; the cost of a shipped bug is far higher than on the web where you can deploy a fix in minutes.
</div>


<h2>4. Quality as a Mindset</h2>

<p>
  Theme 3 isn't a separate phase of development — it's a way of thinking that applies to everything you build. Every time you create a component (Theme 2), you should be asking: is this discoverable? Is the touch target big enough? Can a screen reader navigate it? Every time you add a feature, you should be asking: how do I test this? What happens when the network drops? What happens when the user rotates the screen?
</p>

<p>
  Quality isn't something you add at the end. It's something you build in from the beginning, or you pay for its absence later.
</p>

</body>
</html>
